#!/bin/ash
# vim: foldmarker=[[[,]]]:

# =============================================================================
# Find'N'Run - find and run apps very quickly
  Version=1.10.7-beta1
# authors: Jun-Nov 2015 step; March-May 2015 SFR and L18L.
# license: GNU GPL applies
# requirements: gtk-dialog >= 0.8.3, gawk, ash (or bash)
# source: https://github.com/step-/find-n-run
# forum: http://www.murga-linux.com/puppy/viewtopic.php?t=98330
# =============================================================================

# Localization settings. [[[1
# i18n findnrun.pot file generated with:
# i18n xgettext -ci18n -L Shell -o findnrun.pot --no-wrap --package-name=find-n-run --package-version=1.10.6 --msgid-bugs-address=https://github.com/step-/find-n-run/issues/ findnrun
export TEXTDOMAIN=findnrun
export OUTPUT_CHARSET=UTF-8

# Initialize variables that can be changed. [[[1
# i18n Main window title
APP_NAME=$(gettext "Find'N'Run")
APP_TITLE="${APP_NAME}"

XDG_DATA_DIRS=${XDG_DATA_DIRS:-/usr/share:/usr/local/share}
XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local}

{ read DESKTOP_FILE_DIRS; read ICON_DIRS; } << EOF
$(
  IFS=:
  set -- ${XDG_DATA_HOME} ${XDG_DATA_DIRS}
  for i; do echo -n " $i/applications"; done; echo
  for i; do echo -n " $i/icons"; done; echo
)
EOF
# Ref. http://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html#directory_layout
# Note: Search by icon *theme* isn't implemented.
# Additional Fatdog64-specific locations start at .../midi-icons.
ICON_DIRS="$HOME/.icons ${ICON_DIRS} /usr/share/pixmaps /usr/share/midi-icons /usr/share/mini-icons"

[ -f "${CONFIG}" ] || CONFIG="${HOME}/.findnrunrc"
HELPFILE=/usr/share/doc/findnrun/help[en].tar.gz:/usr/share/doc/findnrun/index.html:/usr/share/doc/findnrun/index.md

# Initialize variables that should not be changed. [[[1
REMARK= # leave unset
DEBUG=${DEBUG:-} # unset to disable debug trace to stderr; set verbosity (integer) 0-10
trap 'rm -rf "${TMPF:-/tmp/dummy}"* ${DEBUG:+/tmp/varSEARCH}' INT QUIT TERM HUP 0
TMPF=`mktemp -d -p "${TMPDIR:-/tmp}" ${0##*/}_XXXXXX` && chmod 755 "${TMPF}"
DATF="${TMPF}/.dat" # database of .desktop file entries
AWKB="${TMPF}/.build.awk" # builds (and queries) database
AWKQ="${TMPF}/.query.awk" # queries database (faster)
HSTF="${TMPF}/.hist-FNR.sh"; >"${HSTF}" # global command line history
FCSF="${TMPF}/.fcs"; >"${FCSF}" # triggers varSEARCH focus grabber
F2SF="${TMPF}/.f2s"; >"${F2SF}" # varCMD/varSEARCH focus cycler
F3SF="${TMPF}/.f3s"; >"${F3SF}" # builtin/plugin source list view cycler
SEP=`echo -e "\b"` # field separator of packed values
ICONCACHE="${HOME}/.icons" # location of icon cache files (in $CONFIG)
SRCSTEM="${TMPF}/.source-" # prefix to source filenames

# -----------------------------------------------------------------------------
#LANG=de_DE.UTF-8 # just for demo
LR=${LANG%.*} #ex:pt_BR
LL=${LANG%_*} #ex:pt

# -----------------------------------------------------------------------------
# Unexport these variables before running the selected command.
UNEXPORT="unset GUI_ABOUT varSEARCH varFOCUSGRABBER varCMD varCOMMENT varOPEN varICONS varFOCUSSEARCH varF2 TEXTDOMAIN OUTPUT_CHARSET"
# unset varLIST and varF3 separately

# Prepare the configuration file. [[[1
# Defaults - match same variable/value pairs in the next block.
defOPEN=false
export varICONS=false
export varFOCUSSEARCH=false
# IBOL+IBOL in search field ignores all characters to beginning of line.
IBOL="­" # 0xAD, dec(173), soft-hyphen, gtk-dialog invisible
HOTKEY_F2=F2
HOTKEY_F3=F3
# Builtin sources: "desktop apps" and "shell completion".
SOURCES="FNRstart FNRsc"

# Read / supplement $CONFIG.
touch "${CONFIG}" && . "${CONFIG}" # must exist even if empty
# Add missing/hidden defaults.
awk '
  /^ICONCACHE=/{f1=1}
  /^SEARCHCOMMENTS=/{f2=1}
  /^SEARCHFROMLEFT=/{f3=1}
  /^SEARCHREGEX=/{f4=1}
  /^CASEDEPENDENT=/{f5=1}
  # GEOMETRY=WxH+X+Y has no default, environment is overridden
  # DESKTOP_FILE_DIRS initialized from system values, environment overrides
  # ICON_DIRS initialized from has system values, environment overrides
  /^SEARCHCATEGORIES=/{f6=1}
  /^SEARCHCOMPLETE=/{f7=1}
  /^IBOL=/{f8=1}
  /^HOTKEY_F2=/{f9=1}
  /^HOTKEY_F3=/{f10=1}
  /^SOURCES=/{f11=1}
  END{
    if(!f1) print "ICONCACHE=\"'"${ICONCACHE}"'\"">>ARGV[1]
    if(!f2) print "SEARCHCOMMENTS=false">>ARGV[1]
    if(!f3) print "SEARCHFROMLEFT=false">>ARGV[1]
    if(!f4) print "SEARCHREGEX=false">>ARGV[1]
    if(!f5) print "CASEDEPENDENT=false">>ARGV[1]
    if(!f6) print "SEARCHCATEGORIES=false">>ARGV[1]
    if(!f7) print "SEARCHCOMPLETE=false">>ARGV[1]
    if(!f8) print "IBOL=\"'"${IBOL}"'\" # reserved">>ARGV[1]
    if(!f9) print "HOTKEY_F2='"${HOTKEY_F2}"'">>ARGV[1]
    if(!f10) print "HOTKEY_F3='"${HOTKEY_F3}"'">>ARGV[1]
    if(!f11) print "SOURCES=\"'"${SOURCES}"'\"">>ARGV[1]
  }
  ' "${CONFIG}"

# Values that depend on defaults.
ICONSTEM="${ICONCACHE}/findnrun-" # prefix to worked-around icons.
mkdir -p "${ICONCACHE}"

# Parse command line --options. [[[1
while ! [ "${1#--}" = "$1" ]; do
  case "$1" in
    --geometry=*) # Override GEOMETRY set in $CONFIG, if any.
      o=${1#--geometry=}; GEOMETRY=${o%--geometry}
      ;;
    --perm=*|--perm) # Tighten tempdir permissions from 755
      o=${1#--perm=}; o=${o%--perm}; chmod "${o:-700}" "${TMPF}"
      ;;
    --) shift; CMDLINEOPTS="$@"; break ;; # pass CMDLINEOPTS to gtkdialog
    --stdout) ENABLESTDOUT=1 ;; # Don't redirect gtkdialog's stdout to null
    --*) echo "${0##*/}: invalid option $1" >&2; exit 1
    ;;
  esac
  shift
done

# More environment variables: BROWSER, LANG [[[1
# =============================================================================

which gtkdialog4 >/dev/null 2>&1 && GTKDIALOG=gtkdialog4 || GTKDIALOG=gtkdialog

# -----------------------------------------------------------------------------
# Set LOCS to the glob that lists valid .desktop file locations.
# Do this in the main shell after having processed script option.
for i in ${DESKTOP_FILE_DIRS}; do
  set -- "$i"/*.desktop
  if [ "$1" != "${1%/*.desktop}/*.desktop" ]; then
    x=${1%% }; x=${x%/*}; LOCS="${LOCS}${LOCS+ }$x/*.desktop"
  else
    : # LOCi is empty or non-existent
  fi
done

# Declare builtin sources. [[[1
# $BUILTIN_SOURCES get special treatment
BUILTIN_SOURCES="FNRstart|FNRsc"

SOURCE_FNRstart="FNRstart:::FNRstart"
TAP_FNRstart="gawk -f \"${AWKQ}\" -v GREP=\"\${term}\" \"${DATF}\"${REDIRECT2}"
TITLE_FNRstart=${APP_NAME}

SOURCE_FNRsc="FNRsc::FNRsc:FNRsc"
# compgen requires bash as gtkdialog back-end shell.
TAP_FNRsc='compgen -ac "${term}" |findnrun-formatter -- -O s -I "${ICON}"'
ICON_FNRsc=findnrun-FNRsc
TITLE_FNRsc=$(gettext "shell completion") # i18n 1.7

# Cache icons of enabled sources.
case " ${SOURCES} " in *' FNRsc '*)
  [ -e "${ICONSTEM}FNRsc.png" ] || cp /usr/share/doc/findnrun/shell-completion.png "${ICONSTEM}FNRsc.png" ;;
esac


# Prepare sources. [[[1
SRCFMT='%d-%s.sh' # source filename format, i.e., printf "%s${SRCFMT}" "${SRCSTEM}" 0 FNRstart
store_valid_sources() # [[[
# In: $SOURCES
# Out: list of valid sources that got stored for gtkdialog sh's use.
# Return value:   <number of valid sources> <list of valid sources>
#   The list of valid sources is a subset of $SOURCES.
# Return code: [[[
# 1-99: fatal; 101-199: recoverable; 201-299: warning.
# If the offending subject is detected it is printed to stderr.
# Fatal errors => gawk exit(code).
# Recoverable errors => print code, disable source and continue.
# Warning => print code and continue.
# 101 source-id isn't a valid shell variable name (SOURCES=)
# 102 null tap-command
# 103 invalid tap-command sh syntax
# 104 invalid drain-command sh syntax
# 111 broken tap-id (leads nowhere)    TODO 111 and up
# 112 broken drain-id
# 113 broken title-id
# 114 broken icon-id
# 201 unreferenced TAP_ (linked by no one)
# 202 unreferenced DRAIN_
# 203 unreferenced TITLE_
# 204 unreferenced ICON_
# 205 unreferenced SOURCE_
#]]]
{
# i18n 1.7 Source plugin validation.
  set | gawk -v SOURCES="${SOURCES}" -v BUILTIN="${BUILTIN_SOURCES}" \
    -v MSG1="$(gettext "fatal source error: %d%s\n")" \
    -v MSG2="$(gettext "recoverable source error: %d%s\n")" \
    -v MSG3="$(gettext "source warning: %d%s\n")" \
'#!/usr/bin/gawk -f
BEGIN {
  TEXTDOMAIN="'"${TEXTDOMAIN}"'"
  if('${DEBUG:-0}') print "\n=== SOURCE DECLARATIONS" > "/dev/stderr"
  # Invalid SOURCES syntax? 101 [[[
  nE = split(SOURCES, E)
  for(j=1; j <= nE; j++) {
    s = E[j] # source-id
    if(match(s, /[^[:alnum:]_ ]|^[[:digit:]]/))
      recoverable(101, s) # exclude invalid source-id
    else
      # include syntactically valid source-id
      valid_sources = valid_sources" "s
  }
  valid_sources = substr(valid_sources, 2)
  # Fall back to BUILTIN source.
  if("" == valid_sources) valid_sources = "FNRstart"
  #]]]
  # id types
  ordered_G = "SOURCE|TAP|DRAIN|ICON|TITLE"
  # G[] array of types
  nG = split(ordered_G, G, /\|/)
  pattern = "^("ordered_G")_([^=]+)=(.*)"
}
{
  if(match($0, pattern, a)) {
    # Parse declarations [[[
    # I[] array of any-type ids a[2]
    # S[] array of source-ids a[1] contained in I[]
    # VGI[] values a[3] by (group a[1], id a[2])
    I[a[2]] = a[2]
    if("SOURCE" == a[1]) S[a[2]] = a[2]
    # Input stream ("set |") formats its output values between single quotes.
    VGI[a[1], a[2]] = substr(a[3], 2, length(a[3])-2) # unquote
    if('${DEBUG:-0}'>4) print a[1],"**",a[2],"**",a[3] > "/dev/stderr"
    #]]]
  }
}
END {
    if('${DEBUG:-0}'>3) {
      printf "# I:" >"/dev/stderr"; for(i in I) printf(" %s", i) >"/dev/stderr"
      print "" >"/dev/stderr"
      printf "# S:" >"/dev/stderr"; for(s in S) printf(" %s", s) >"/dev/stderr"
      print "" >"/dev/stderr"
      for(i in I) {
        for(j=1; j<=nG; j++) {
          g = G[j]
          if((g, i) in VGI)
            printf("# <%s, %s> = %s\n", g, i, VGI[g, i]) >"/dev/stderr"
        }
      }
    }
  # TS[] array of tap-ids by source-id
  # DS[] array of drain-ids by source-id
  for(s in S) {
    split(VGI["SOURCE",s], a, /:/)
    if(a[1]) TS[s] = a[1] # TODO should use symbols, not number
    if(a[2]) DS[s] = a[2] # ditto
    # Localize title; ditto
    if(a[4]) VGI["TITLE", a[4]] = dcgettext(VGI["TITLE", a[4]], "findnrun-plugin-"s)
    if('${DEBUG:-0}'>4)
      printf "source %s: TAP %s DRAIN %s\n", s, \
        (s in TS) ?TS[s] :"NULL", (s in DS) ?DS[s] :"NULL" >"/dev/stderr"
  }
  # Null tap-command? 102 [[[
  for(s in S) if(! (("TAP", s) in VGI) || ! VGI["TAP", s]) {
    recoverable(102, s)
    delete S[s]
  }
  #]]]
  # Invalid tap-command sh syntax? 103 [[[
  syntax_check("TAP", TS, S, 103) # deletes elements of S
  #]]]
  # Invalid drain-command sh syntax? 104 [[[
  syntax_check("DRAIN", DS, S, 104) # deletes elements of S
  #]]]
  # Store remaining valid sources for gtkdialog shell. [[[
  # Treat sources as an ordered list.
  nE = split(valid_sources, E)
  for(j=1; j <= nE; j++) {
    if(! (E[j] in S)) continue
    s = E[j] # source-id
    store_source(s)
    return_sources = return_sources" "s
  }
  return_sources = substr(return_sources, 2)
  #]]]
  # Append NSOURCES= to all saved files. [[[
  nsources = split(return_sources, a)
  for(j=0; j < nsources; j++) {
    saveas = sprintf("%s'"${SRCFMT}"'", "'"${SRCSTEM}"'", j, a[j+1])
    printf("NSOURCES='"'%d'"'\n", nsources) >> saveas
    close(saveas)
  }
  #]]]
  # Return valid sources
  print nsources, return_sources
}
function syntax_check(group, A, I, code,   i, checker, status) { # [[[
  # Checks all items of A. Deletes items of I.

  # The best syntax checker that we can get, but still quite limited.
  checker = "sh -n"

  if('${DEBUG:-0}'>3) { #[[[
    print "\nsyntax_check",group,":" >"/dev/stderr"
    for(i in A) print "source",i, \
      (i in I) ?"to check" :"is already invalid", \
      "(declares", group, A[i]")" >"/dev/stderr"
  } #]]]
  # For each declared source-id as i that is associated with a non-null group-id...
  #   If source-id i is still in the set of valid ids (I)
  #   && its group-id A[i] has an associated value in VGI...
  for(i in A) if(i in I && ((group, A[i]) in VGI)) {
    if(match(BUILTIN, i)) continue # optimization: skip builtin sources
    if('${DEBUG:-0}'>3) #[[[
      print "now checking",i"'"'"'s", group, A[i],"=>", \
        VGI[group, A[i]] >"/dev/stderr" #]]]
    print VGI[group, A[i]] | checker
    if(close(checker)) { # non-zero exit code on invalid syntax
      recoverable(code, group": "VGI[group, A[i]], i)
      delete I[i]
    }
  }
}
#]]]
function store_source(s, buf, A,   a, g, i, j, I) { #[[[
  # NOTE store_source increments global static variable _global_store_source.
  # Call store_source for the ORDERED list of valid sources.
  # In => Out:
  #   s source-id
  #   buf==""      => compose from globals G and VGI for s; OR
  #     Note1: on null title-id output source-id as title value
  #     Note2: on null other-id output null value, i.e., VAR='' << IMPORTANT
  #   buf=="array" => compose from A["SOURCE"]=source-id, A["TAP"]=tap-command, ...
  # Note3: output values will be wrapped in single quotes.
  # Assert: input values can be safely wrapped in single quotes because they
  # were formatted with (piped from) the sh "env" command.
  if("" == buf) {
    buf = sprintf("ID='"'%s'"'", s)
    split(s":"VGI["SOURCE",s], I, /:/)
    for(j = 1; j <= nG; j++) {
      g = G[j]; i = (j in I) ?I[j] :"N\x08NULL" # \x08 => never "(g,i) in VGI"
      if('${DEBUG:-0}'>2) printf ("<%s, %s> ", g, i) > "/dev/stderr"
      if((g, i) in VGI)
          buf = buf sprintf("\n%s='"'%s'"'", g, VGI[g, i])
      else if("TITLE" == g)
          buf = buf sprintf("\n%s='"'%s'"'", g, s) # Note1
      else
          buf = buf sprintf("\n%s='"''"'", g) # Note2
    }
  } else if("array" == buf) { # NOT USED
    buf = sprintf("ID='"'%s'"'", s)
    for(a in A)
      buf = buf sprintf("\n%s='"'%s'"'", a, A[a])
  }
  saveas = sprintf("%s'"${SRCFMT}"'", "'"${SRCSTEM}"'", 0+_global_store_source++, s)
  print buf > saveas
  if('${DEBUG:-0}'>2) print "\n"buf > "/dev/stderr"
  return close(saveas)
}
#]]]
function fatal(code, subject, source) { #[[[
  printf(MSG1, code, \
    (source ?" "source":" :"") (subject ?" "subject :"")) > "/dev/stderr"
  exit(code)
}#]]]
function recoverable(code, subject, source) { #[[[
  printf(MSG2, code, \
    (source ?" "source":" :"") (subject ?" "subject :"")) > "/dev/stderr"
}#]]]
function warning(code, subject, source) { #[[[
  printf(MSG3, code, \
    (source ?" "source":" :"") (subject ?" "subject :"")) > "/dev/stderr"
}#]]]
  '
}
#]]]

store_valid_sources > "${TMPF}/.$$"
x=$?; [ 0 -lt $? -a $? -lt 100 ] && exit $x # fatal errors
read NSOURCES sources < "${TMPF}/.$$" # all and only valid sources
# Read first source's values to be used to initialize gtkdialog <default>'s.
. "${SRCSTEM}0-"*.sh

# If some sources were disabled display startup warning dialog. [[[
if [ "${sources}" != "${SOURCES}" ]; then
   # TODO display gtkdialog window over main window.
   # i18n 1.7 TEMPORARY
  Xdialog --title "${APP_NAME}" --msgbox \
    "$(gettext 'Invalid source plugins found and disabled.')" 0x0
fi
#]]]
# Prepare the database builder script. [[[1
# Usage: gawk -f "${AWKB}" [-v GREP="string"] [-v ALL_ICONS=true] files
[ -x /bin/dash ] && SH=/bin/dash || SH=/bin/ash
> "${AWKB}" echo '#!/usr/bin/gawk -f
BEGIN {
  if("'${DEBUG:-0}'">0) print "\nstart db builder [[ ALL_ICONS="ALL_ICONS >"/dev/stderr"
  RS="^~cannot~match~me~" # enable slurp read mode.
  # Choose a shell for ongoing command execution - see icon_workaround().
  sh = "'${SH}'" # not used as a coprocess
  ICONSTEM = "'"${ICONSTEM}"'" # prefix to worked-around icons.
  if("'${DEBUG:-0}'">1) print "ICONSTEM="ICONSTEM >"/dev/stderr"
}
{
  # Slurp NFILES .desktop files.
  file[++NFILES]=";"FILENAME"\n"$0
  FILENAME="-in-section-END-"
}
END {
  # Is the icon work-around enabled and up-to-date?
  if(ICONUPDATED = is_icon_workaround_uptodate()) {
    # Speed up icon_workaround() by reading the icon index file.
    read_icon_index() # creates ICONINDEX map
  }
  # Decode .desktop files.
  if("'${DEBUG:-0}'">0) print "awk decoding",NFILES,"files..." > "/dev/stderr"
  for(i=1; i<=NFILES; i++) {
    fil=file[i]
    name=exec=icnpath=icnname=icnext=comment=category=""
    match(fil, /^;([^\n]+)/, m); filename=m[1]
    match(fil, /\nName=([^\n]+)/, m); name=m[1]
    if(match(fil, /\nName\[('"${LR:-@}|${LL:-@}"')\]=([^\n]+)/, m)) name=m[2]
    if(!name) continue # trap bogus .desktop files
    match(fil, /\nExec=([^\n]+)/, m); exec=m[1]
    if(!exec) continue # trap bogus .desktop files
    # Delete freedesktop.org %F parameter since Exec= value is going to sh.
    sub(/[ \t]*%[a-zA-Z][ \t]*$/, "", exec)
    match(fil, /\nIcon=([^\n]*\/)?([^\n.]+)([.][^\n]*)?/, m)
    icnpath=m[1]; icnname=m[2]; icnext=substr(m[3],2)
    match(fil, /\nComment=([^\n]+)/, m); comment=m[1]
    if(match(fil, /\nComment\[('"${LR:-@}|${LL:-@}"')\]=([^\n]+)/, m)) comment=m[2]
    match(fil, /\nCategories=([^\n]+)/, m); category=";"m[1]
    # narrow matches by GREP pattern and store for sorting step
    if(GREP && index(tolower(name), GREP) || !GREP) {
      if(key[k = tolower(name)]) { # case-independent sort; assert name != ""
        # Handle key clash by appending "%<" to the key N times on N-th clash.
        while(key[k = k"%<"]);
      }
      key[k] = k
      if(ALL_ICONS == "true") icon_workaround(sh)
      out[k] = format_item()
    }
  }
  # Sort by name and print.
  nkey = asort(key) # Note: asort is a GNU awk (gawk) extension.
  for(i=1; i<=nkey; i++) {
    print substr(out[key[i]], 1, 510)
    # 510 works around gtkdialog tree widget buffer overflow limit
  }
  # Remember if we performed a complete icon work-around.
  mark_icon_workaround_uptodate()
  # Close shell.
  print "exit" | sh
  close(sh)
  if("'${DEBUG:-0}'">0) print "]] builder done" >"/dev/stderr"
}

# Format tree widget item - columns: icon, name, all-packed-values.
# Note: assert data does not include characters "|" and $SEP.
function format_item(   ic,cols) {
  ic = format_icon_cell()
  # The second column, always empty, is reserved for future expansion.
  # The tree widget does display its value.
  cols = sprintf("%s||%s|%s", \
    ic, name, \
    sprintf("%s'${SEP}'%s'${SEP}'%s'${SEP}'%s'${SEP}'%s", \
    filename,name,exec,comment,category))
    # tree widget exports all packed values as a single column
  return(cols)
}

# Format tree row icon cell.
# Use within <input icon-column="0"> or <stock-column="0">
# Note: tree widget does not support icons with paths anyway.
function format_icon_cell( ) {
  return(icnpath ? icnpath icnname "." icnext : icnname)
}

# Workaround for gtkdialog tree widget not displaying icons with path.
function icon_workaround(sh,    a,c,IFP,ifp,x,lnk,ext) {
  # Supposedly, IFP is the icon full path (it is used as the icon index key).
  IFP = icnpath icnname (icnext ?".":"") icnext
  if("" == IFP) return
  # If the work-around is not up-to-date run sh/find/ln to create icon links.
  if(!ICONUPDATED) {
    #printf "L" > "/dev/stderr"
    ifp = IFP
    c = ""
    if(-1 == getline < ifp) { # file ifp does not exist
      # This could happen because .desktop file sets Icon=name-only (valid), but
      # we cannot trust gtkdialog to show icons by name without extension, so
      # get the full pathname; ref. http://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html#icon_lookup
      c = "2>/dev/null find -L '${ICON_DIRS}' " \
        " -type f \\( -name \""icnname".png\" -o -name \""icnname".svg\" -o -name \""icnname".xpm\" \\) -print0 -quit"
        # ! -path "*/.*/*" excludes all matches within any hidden dir, neat!
        # -print0 ensures match string does not include \n character
        # -quit exits after first match, if any; GNU awk (gawk) extension.
      # Read found path into ifp, which stays == "" if nothing found.
      ifp=""; c | getline ifp; close(c)
      # Note that ifp is null-terminated. See \x00 below.
    } else { # file ifp exists
      close(ifp)
    }
    if("" != ifp) {
      sub(/\x00/,"",ifp)
    } else {
      print filename": Icon=" icnpath icnname "." icnext, "Not found." >"/dev/stderr"
      return
    }
    # gtkdialog tree can definitely display icon paths /usr/share/pixmaps/*
    # so try symlinking to target ifp
    x = split(ifp, a, /\//)
    lnk = a[x] # link name lnk <- icon-name[.ext] (no path)
    ext = (x = split(lnk, a, /\./)) ?"."a[x] :"" # ".ext" if any
    if(ext) x-- # forget ext from split link name
    # implode link name while replacing all dots with underscores
    lnk = ""; for(c=1; c<=x; c++) lnk = lnk "_" a[c]; lnk = substr(lnk, 2)
    # Symlink the icon.
    print "2>/dev/null ln -s \""ifp"\" \"" ICONSTEM lnk ext "\"" | sh
    # Progressively build the icon index file.
    printf "%s\x00%s\x00%s\x00%s\n", IFP, ifp, lnk, ext >> (ICONSTEM".index")
  } else {
    #printf "I" > "/dev/stderr"
    # The work-around is up-to-date so use ICONINDEX map to speed things up
    split(ICONINDEX[IFP], a, "\x00")
    lnk = a[3]
  }

  icnpath = "" # this tells format_item() to use icnname only
  icnname = "findnrun-" lnk # no ext
  # gtkdialog is very finicky: icon name must not include dots nor extension
  # but the link name must include an extension!
}

# Is the icon work-around enabled and up-to-date? - icon_workaround() helper.
function is_icon_workaround_uptodate(   uptodate,x) {
  if(uptodate = ("true" == ALL_ICONS)) {
    if(uptodate = (-1 != (getline < (x = ICONSTEM".uptodate"))))
      close(x)
  }
  if("'${DEBUG:-0}'">1) print "is_icon_workaround_uptodate="uptodate > "/dev/stderr"
  return(uptodate)
}

# Read the index file - icon_workaround() helper
function read_icon_index(   a,b,data,i,x) {
  if("'${DEBUG:-0}'">1) print "in read_icon_index" >"/dev/stderr"
  if(1 == (getline data < (x = ICONSTEM".index"))) {
    close(x)
    na = split(data, a, /\n/) # we slurped the index file
    for(i=1; i<=na; i++) {
      split(a[i], b, "\x00") # index record fields: IFP ifp lnk ext
      ICONINDEX[b[1]] = a[i]
    }
  }
}

# If the icon work-around is enabled, mark whether it is up-to-date.
function mark_icon_workaround_uptodate( ) {
  if("true" == ALL_ICONS) {
    print "" > (ICONSTEM".uptodate")
    if("'${DEBUG:-0}'">1) print "\nmark_icon_workaround created", ICONSTEM".uptodate" > "/dev/stderr"
  }
}
'

# Prepare the database query script. [[[1
# Usage: gawk -f "${AWKQ}" [-v GREP="string"] ${DATF}
unset case subject commleft left categ REDIRECT2 func statements
[ true = "${CASEDEPENDENT}" ] || case=tolower
if ! [ true = "${SEARCHCOMPLETE}" ]; then
  # Split out the last field of the record that $AWK's format_item() printed.
  statements="
  split(\$(NF), a, /${SEP}/) # a <- {filename,name,exec,comment,category}"
  subject="${case}(a[2])"
else
  # Ignore last record's first sub-field (filename).
  statements="
  a=\$(NF); a=substr(a,1+index(a,\"${SEP}\"))"
  subject="${case}(a)" # ="${case}(a[2]\";\"a[3]\";\"a[4]\";\"a[5])"
fi
if [ true = "${SEARCHREGEX}" ]; then
  REDIRECT2=" 2>/dev/null" # Quiet awk's "fatal: invalid regex" message
  func=match
  [ true = "${SEARCHFROMLEFT}" ] && left="&& RSTART==1"
else
  func=index
  [ true = "${SEARCHFROMLEFT}" ] && left="==1"
fi
subject="${func}(${subject},GREP)"
if ! [ true = "${SEARCHCOMPLETE}" ]; then
  [ true = "${SEARCHCOMMENTS}" ] && commleft="|| ${func}(${case}(a[4]),GREP)${left}"
  [ true = "${SEARCHCATEGORIES}" ] && categ="|| ${func}(${case}(a[5]),GREP)"
fi
> "${AWKQ}" echo '#!/usr/bin/gawk -f
BEGIN {
  if("'${DEBUG:-0}'">2) {
    print "\nstart db querier [[ GREP=\""GREP"\"" >"/dev/stderr"
    print "expression=('"${subject}${left} ${commleft} ${categ}"')" >"/dev/stderr"
  }
  FS="|"
}
{'"${statements}"'
  # narrow matches by GREP pattern
  if(GREP && ('"${subject}${left} ${commleft} ${categ}"') || !GREP) {
    print substr($0, 1, 510)
    # 510 works around gtkdialog tree widget buffer overflow limit
  }
}
END {
  if("'${DEBUG:-0}'">2) print "]] querier done" >"/dev/stderr"
} '

# Build database of .desktop file entries. [[[1
gawk -v ALL_ICONS=${varICONS} -f "${AWKB}" ${LOCS} > "${DATF}"
[ "${DEBUG:-0}" -gt 0 ] && { >/tmp/varSEARCH; echo >&2 accepting input from /tmp/varSEARCH; }
NDATF=$(wc -l "${DATF}"); NDATF=${NDATF%% *}

# Prepare Help system and its GUI button (About). [[[1
# i18n About dialog.
find_help() #[[[
{
  # In:  ${HELPFILE} paths.
  # Out: ${helpviewer} command, ${helpbutton} gtk code.
  local IFS=:
  set ${HELPFILE}
  for i; do
    unset x p s helpviewer helpbutton; hf="$i"
    case "${hf}" in *\[*\]*) p="${hf%[*}["; s="]${hf##*]}" # search for translation
      [ -e "$p${LL}$s" ] && hf="$p${LL}$s"; [ -e "$p${LR}$s" ] && hf="$p${LR}$s"; [ -e "$p${LANG}$s" ] && hf="$p${LANG}$s" ;;
    esac
    if [ -e "${hf}" ]; then
      hd="${TMPF}/help" && mkdir -p "${hd}" &&
      case "${hf##*.}" in t[gx]z|[gx]z) tar -C "${hd}" -xaf "${hf}" && hf=$(set +f; echo "${hd}"/index.*) ;; esac &&
      case "${hf##*.}" in md) x=mdview ;; htm*) x=defaultbrowser;; esac
      read -t 1 helpviewer << EOF
$(which $x www-browser x-www-browser defaulttexteditor geany leafpad 2>&-)
EOF
      case ${helpviewer} in
        '') helpviewer="${BROWSER:-xdg-open} '${hf}'";; # catchall
        *mdview) helpviewer="'${helpviewer}' '${hf%/*}' '${hf##*/}' '${hf##*/}' \"${APP_TITLE}\"" ;;
        *browser) helpviewer="'${helpviewer}' 'file://${hf}'" ;;
        *) # dup help files to protect sources from text editors
          if ! [ "${hf%/*}" = "${hd}" ]; then cp -fr "${hf%/*}/"* "${hd}/"; fi &&
          helpviewer="cd '${hd}' && '${helpviewer}' 'no-help.md'" ;;#${hf##*.}'";;
      esac &&
      helpbutton="
<button use-underline=\"true\">
  <label>$(gettext "_Help")</label>
  <input file stock=\"gtk-help\"></input>
  <action>${helpviewer} &</action>
  <action>closewindow:GUI_ABOUT</action>
</button>"
    break # on first valid help file path $hf found
  fi
  done
}
#]]]
find_help

# i18n About dialog widgets: window text; number of apps text (singular/plural)
# i18n 1.7 use %s for authors.
export GUI_ABOUT='
<window title="'"${APP_TITLE}"'" icon-name="edit-find" window-position="2">
  <vbox>
    <frame>
      <text justify="0" selectable="true" can-focus="false">
        <label>"'"$(printf "$(gettext "%s %s
authors: %s
Open source - GNU GPL license applies

%s
%s

configuration: %s
")" "${APP_NAME}" "${Version}" "SFR, L18L, step" \
"http://www.murga-linux.com/puppy/viewtopic.php?t=98330" \
"https://github.com/step-/find-n-run" "${CONFIG}")
$(printf "$(ngettext "%s application found" "%s applications found" "${NDATF}")" "${NDATF}"
)"'"</label>
      </text>
    </frame>
    <hbox homogeneous="true">
      <text space-fill="true" space-expand="true"><label>""</label></text>
      <button use-underline="true">
        <label>'"$(gettext "_OK")"'</label>
        <input file stock="gtk-ok"></input>
        <action>closewindow:GUI_ABOUT</action>
      </button>
      '"${helpbutton}"'
      <text space-fill="true" space-expand="true"><label>""</label></text>
    </hbox>
  </vbox>
  <variable>GUI_ABOUT</variable>
  <action signal="key-press-event" condition="command_is_true([ $KEY_SYM = Escape ] && echo true )">closewindow:GUI_ABOUT</action>
</window>'

# Helpers [[[1

generate_get_source() # [[[2
{
  # Echo sh code that loads the current source's field values.
  echo -n ". \"${SRCSTEM}\"\${varF3:-0}-*.sh"
}
generate_rotated_sources() # $1-sh-fragment  [[[2 NOT USED
{
  # Echo sh code that executes sh-fragment for the current source index (varF3, numeric).
  # Example (gtkdialog):
  #<entry>
  #  <variable>varF3SYM</variable>
  #  ${REMARK# Cache source-id value until next refresh:varF3SYM.}
  #  <input>$(generate_rotated_sources "echo -n \"\$1\"")</input>
  #</entry>
  local fragment nsources i
  fragment=$1
  set -- ${SOURCES:-FNRstart}
  nsources=$#
  # Switch rotated source-ids.
  echo -n 'set -- '"${SOURCES}"'; shift ${varF3:-0}'
  echo -n '; case $1 in'
  i=0; while [ $# -gt 0 -a $i -le ${nsources} ]; do
    echo -n " $i|$1) ${fragment} ;;"
    shift
    i=$(($i + 1))
  done
  echo -n " esac"
}

generate_invoke_source_tap() # [[[2
{
  # Echo sh code that invokes source[varF3]'s tap-command.
  # Extract search input value as $term with IBOL+IBOL correction. [[[
  echo -n 'ifs="${IFS}"; IFS="'"${IBOL}"'"; set -f; set -- ${varSEARCH}; for i; do term="$i"; done; set +f; set IFS="${ifs}"'
  #]]]
  # Get source[varF3]'s values. [[[
# Optimization: use cached <variable>TAP</variable>.
# -z takes care of first source's first typed search case. [[[
# For it to work correctly <variable>TAP must have NO <default> tag.]]]
  echo -n '; if [ -z "${TAP}" ]; then '
  generate_get_source
  echo -n '; fi'
  # ]]]
  # Start tap-command. [[[
  echo -n ' && case ${HINTS} in'
  echo -n  ' *term*) eval ${TAP} "${term}" ;;'
  echo -n  ' *) eval ${TAP} ;;'
  echo -n ' esac'
  #]]]
}

generate_invoke_source_drain() # [[[2
{
  # Echo sh code that invokes source[varF3]'s drain-command.
  # Extract selected list item value as "$@". [[[
  echo -n 'ifs="${IFS}"'
  # NOTE: Imitate this command line in varCMD's <input> !
  echo -n '; IFS="'"${SEP}"'"; set -f; set -- ${varLIST}; set -- $3; set +f'
  echo -n '; unset varLIST; IFS="${ifs}"'
  #]]]
  # Unexport all vars but varF3 and varLIST.
  echo -n "; ${UNEXPORT}"
  # Get source[varF3]'s values. [[[
  echo -n '; '; generate_get_source
  # ]]]
  # Save command to history lists. [[[
  # To the source's own history list file + FNR's global history list file.
  # ${HSTF} points to one of the two files, and it's used as input to the command history widget.
  echo -n "; echo "\${DRAIN}\${DRAIN:+ }" "\$@" >> '${TMPF}/.hist-${ID}.sh'"
  echo -n "; echo "\${DRAIN}\${DRAIN:+ }" "\$@" >> '${TMPF}/.hist-FNR.sh'"
  #]]]
  # Start drain-command. [[[
  echo -n '; set -- ${DRAIN} "$@"'
  echo -n '; unset TAP DRAIN ICON TITLE HINTS varF3'
  echo -n '; eval "$@" &'
  #]]]
}

generate_status_bar() # [[[2
{
  # Echo sh code that loads the current and next source's titles
  # and sets them as navigation hotkey labels.
  set -- ${SOURCES:-FNRStart}
  [ $# -lt 2 ] && return # no status bar unless:
  # Multiple sources. [[[
  #i18n 1.7 Status bar: Ctrl+0... and F3... hotkeys
  local ctrlnkey funckey
  ctrlnkey=$(gettext "[ctrl+%d]") funckey=$(gettext "[%s]")
  echo -n '
    <vbox>
      <statusbar has-resize-grip="false" sensitive="false">
        <variable export="false">varSBAR</variable>
        <input>'
  echo -n "${DEBUG:+set -x; }"
  echo -n 'title="${TITLE}"' # This is a gtkdialog sh variable and...
  # [[[ ... it gets its value from the <input> tag, which is activated only
  # after refresh:TITLE. Adding a <default> tag value for TITLE doesn't
  # initialize its **sh value**. It only initializes its **widget** value.
  # Again, here we deal with the gtkdialog sh value, so we need to be
  # prepared to the null value case, which manifests itself only once,
  # when gtkdialog starts. Here it goes.
  #]]]
  echo -n '; [ -z "${title}" ] && . "'"${SRCSTEM}"'"${varF3:-0}-*.sh && title="${TITLE}"'
  # Load next source's values
  echo -n '; . "'"${SRCSTEM}"'"$(((${varF3:-0} + 1) % ${NSOURCES:-'${NSOURCES}'}))-*.sh'
  echo -n '; next="${TITLE}"'
  # Send formatted data to SBAR.
  echo -n '; printf "'"%s ${ctrlnkey}  »  ${funckey} %s"'" "${title}" $((${varF3}+1)) "'"${HOTKEY_F3}"'" "${next}"'
#  echo -n '; printf "'"${ctrlnkey} %s  »  %s ${funckey}"'" $((${varF3}+1)) "${title}" "${next}" "'"${HOTKEY_F3}"'"'
  echo "</input>
        ${DEBUG:+<action>echo>&2 ,,, varSBAR ,,,</action>}
      </statusbar>
    </vbox>"
  #]]]
}

generate_source_hotkeys() # [[[2
{
  #echo '<action signal="key-press-event">echo "MOD=$KEY_MOD RAW=$KEY_RAW SYM=$KEY_SYM UNI=$KEY_UNI VAL=$KEY_VAL">&2</action>'
  local i p
  set -- ${SOURCES:-FNRstart}
  i=0; while [ $# -gt 0 -a $i -lt 9 ]; do
    p=$(($i + 1))
    echo '
  <action signal="key-press-event" condition="command_is_true([ $KEY_MOD = 4 -a $KEY_SYM = '$p' ] && echo true )">echo -n '$i' >"'"${F3SF}"'"</action>
  <action signal="key-press-event" condition="command_is_true([ $KEY_MOD = 4 -a $KEY_SYM = '$p' ] && echo true )">refresh:varF3</action>'
    shift
    i=$p
  done
}

start_dialog() # [[[2
{
  if [ ${DEBUG:-0} -gt 9 ]; then
    cat
    return
  fi
  if [ "${ENABLESTDOUT}" ]; then
    $GTKDIALOG ${GEOMETRY:+--geometry=}${GEOMETRY} ${CMDLINEOPTS} -s
  else
    $GTKDIALOG ${GEOMETRY:+--geometry=}${GEOMETRY} ${CMDLINEOPTS} -s >/dev/null
  fi
}

# Prepare and show the main window. [[[1
unset showcategories
[ true = "${SEARCHCATEGORIES}" ] && showcategories=true
# i18n Main window widgets: entry tooltip; entry default; icon tooltip; list tooltip; pull-down tooltip; pull-down default; pull-down icon tooltip; entry tooltip; {checkbox tooltip; checkbox label}repeat(3); {button icon tooltip}repeat(2)
# i18n "0" (invisible, disregard).
gettext 0 >/dev/null # work around an xgettext's limitation
start_dialog << EOF
<window title="${APP_TITLE}" icon-name="edit-find" window-position="2">
  <vbox>
    ${REMARK# [[[. varSEARCH: progressive typing search input field.}
    <hbox spacing="0">
      <entry auto-refresh="${DEBUG:+true}" tooltip-text="$(gettext "Press ENTER to select")">
        ${REMARK# [[[. Entering IBOL+IBOL makes the search input field}
        ${REMARK# ignore all characters to the left of IBOL+IBOL included.}
        ${REMARK# IBOL stands for Ignore To Beginning Of Line. Its default}
        ${REMARK# value is the soft-hyphen character, which is invisible in}
        ${REMARK# gtkdialog. Here we append IBOL+IBOL to the default search}
        ${REMARK# term so that the entire value --which is simply a help tip}
        ${REMARK# is ignored, and the search engine can perform a clean query.}
        <default>$(gettext "Type some letters to refine the list")${IBOL}${IBOL}</default>
        ${REMARK# ]]]}
        <variable>varSEARCH</variable>
        ${REMARK# The entry widget ignores initial input unless it is refreshed, see varSEARCH0.}
        <input>echo -n ${INITSEARCH}</input>
        ${DEBUG:+<input file>/tmp/varSEARCH</input>}
        ${DEBUG:+<action>echo>&2 ,,, varSEARCH ,,,</action>}
        <action>refresh:varLIST</action>
        <action signal="activate">grabfocus:varLIST</action>
        <action signal="activate">echo false>"${FCSF}"</action>
      </entry>
      <button tooltip-text="$(gettext "Clear entry")" stock-icon-size="1">
        <input file stock="gtk-clear"></input>
        <action>grabfocus:varSEARCH</action>
        <action>clear:varSEARCH</action>
      </button>
    </hbox>
    ${REMARK# ]]]}
    ${REMARK# varSEARCH0: refresh initial search input. [[[}
    <hbox space-expand="false">
      <timer milliseconds="true" interval="100" visible="true">
        <variable>varSEARCH0</variable>
        <action>refresh:varSEARCH</action>
        ${REMARK# varF3 re-enables this timer when another plugin gets loaded.}
        <action>disable:varSEARCH0</action>
      </timer>
    </hbox>
      ${REMARK# - ]]]}
    ${REMARK# [[[. varLIST: list tap-data records.}
    <tree enable-search="false" exported-column="2" column-visible="1|1|0" headers-visible="false" icon-column-name="gtk-apply" hscrollbar-policy="1" vscrollbar-policy="1" tooltip-text="$(gettext "Press ENTER or double-click to run the selected item")">
      ${REMARK# Column names below. So Reserved and Label only are visible.}
      ${REMARK# Consider also that there is an icon column, so a full input}
      ${REMARK# record is defined as Icon|Reserved|Label|PackedValues }
      <label>Reserved|Label|PackedValues</label>
      <variable>varLIST</variable>
      ${REMARK# [[[. Populate list view.}
      <input icon-column="0">${DEBUG:+set -x; }$(generate_invoke_source_tap)</input>
      ${REMARK# ]]]}
      ${DEBUG:+<action>echo>&2 ,,, varLIST ,,,</action>}
      ${REMARK# [[[. Process list view selection.}
      <action>${DEBUG:+set -x; }$(generate_invoke_source_drain)</action>
      ${REMARK# ]]]}
      <action condition="active_is_false(varOPEN)">exit:EXIT</action>
      <action signal="changed">refresh:varCMD</action>
      <action signal="changed">clear:varCOMMENT</action>
      <action signal="changed">refresh:varCOMMENT</action>
      ${DEBUG:+<action>echo >&2 auto-refreshing varFOCUSGRABBER</action>}
      <action>( sleep 0.1 || sleep 1; echo "\${varFOCUSSEARCH}">"${FCSF}"; ) &</action>
    </tree>
    ${REMARK# ]]]}
    ${REMARK# [[[. varFOCUSGRABBER: handle varLIST on(EnterEnter|double-click).}
    ${REMARK# input file auto-refresh rate cannot be configured. http://code.google.com/p/gtkdialog/source/detail?r=453}
    ${REMARK# gtkdialog compiled w/o inotify refreshes about once a second. With inotify refreshing is instantaneous.}
    <checkbox auto-refresh="true" visible="false">
      <default>false</default>
      <variable>varFOCUSGRABBER</variable>
      <input file>${FCSF}</input>
      ${DEBUG:+<action>echo>&2 ,,, varFOCUSGRABBER ,,,</action>}
      ${DEBUG:+<action>if true echo >&2 'grabfocus:varSEARCH'</action>}
      <action>if true grabfocus:varSEARCH</action>
      <action>if true echo false>"${FCSF}"</action>
      <action>if true clear:varFOCUSGRABBER</action>
    </checkbox>
    ${REMARK# ]]]}
    ${REMARK# [[[. varCMD: command history editing.}
    <hbox space-fill="false" space-expand="false">
      <comboboxentry space-expand="true" space-fill="true" tooltip-text="$(gettext "Press the down-arrow key to grab the selected item and move through the history list. You can edit the grabbed entry. History persists while the program is running. History is cleared on exit.")">
        <variable>varCMD</variable>
        <default>$(gettext "Press down-arrow key to grab command")</default>
        ${REMARK# NOTE: Commands imitate varLISTs action, see generate_invoke_source_drain().}
        <input>IFS="${SEP}"; set -f; set -- \${varLIST}; set -- \$3; set +f; echo "\$@"</input>
        <input>awk '{a[++i]=\$0}END{while(i>0)print a[i--]}#tac' "${HSTF}"</input>
        <output file>${HSTF}</output>
        ${DEBUG:+<action>echo>&2 ,,, varCMD ,,,</action>}
        <action signal="activate" condition="command_is_true(echo \${varCMD:-true})">break:</action>
        <action signal="activate">set -- \${varCMD}; echo "\$@" >> "${HSTF}"; ${UNEXPORT} varLIST varF3; eval "\$@" &</action>
        <action signal="activate" condition="active_is_false(varOPEN)">exit:EXIT</action>
        <action signal="activate" condition="command_is_true(echo \${varFOCUSSEARCH})">grabfocus:varSEARCH</action>
        <action signal="activate" condition="command_is_false(echo \${varFOCUSSEARCH})">grabfocus:varLIST</action>
        <action signal="activate">refresh:varCMD</action>
      </comboboxentry>
      <button tooltip-text="$(gettext "Remove entry from command history")" stock-icon-size="1">
        <input file stock="gtk-remove"></input>
        <action>grabfocus:varCMD</action>
        <action>removeselected:varCMD</action>
        <action>save:varCMD</action>
        <action>refresh:varCMD</action>
      </button>
    </hbox>

    <entry sensitive="false" tooltip-text="$(gettext "Comment about current item")">
      <variable>varCOMMENT</variable>
      <input>IFS=${SEP}; set -- \${varLIST}; echo "\$4${showcategories:+ \$5}"</input>
    </entry>
    ${REMARK# ]]]}
    ${REMARK# [[[. Options and tools (bottom bar)}
    <hbox space-fill="false" space-expand="false">
      ${REMARK# [[[. varOPEN checkbox}
      <checkbox use-underline="true" tooltip-text="$(gettext "Keep this window open after starting an item instead of closing this window each time a command starts. Keep the window open to use the command history feature, or to avoid startup delays.")">
        <label>$(gettext "_Keep window")</label>
        <default>${defOPEN}</default>
        <variable>varOPEN</variable>
        ${DEBUG:+<action>echo>&2 ,,, varOPEN ,,,</action>}
        <action>awk -v s=defOPEN=\${varOPEN} '/^defOPEN=/{\$0=s;f=1}{a[++n]=\$0}END{if(!f)a[++n]=s;++n;for(i=1;i!=n;i++)print a[i]>ARGV[1]}' '${CONFIG}'</action>
      </checkbox>
      ${REMARK# ]]]}
      ${REMARK# [[[. varICONS checkbox}
      <checkbox use-underline="true" tooltip-text="$(gettext "Display all available icons instead of displaying just the icons that do not need to be cached. Caching all icons may take some time. Disabling this option clears the existing cache.")">
        <label>$(gettext "_Show all icons")</label>
        <default>${varICONS}</default>
        <variable>varICONS</variable>
        ${DEBUG:+<action>echo>&2 ,,, varICONS ,,,</action>}
        <action>awk -v s=varICONS=\${varICONS} '/^varICONS=/{\$0=s;f=1}{a[++n]=\$0}END{if(!f)a[++n]=s;++n;for(i=1;i!=n;i++)print a[i]>ARGV[1]}' '${CONFIG}'</action>
        <action>clear:varSEARCH</action>
        ${DEBUG:+<action>ls /usr/share/pixmaps/findnrun-.uptodate ~/.icons/findnrun-.uptodate >&2; cat ~/.findnrunrc >&2</action>}
        <action condition="command_is_true([ -f '${ICONSTEM}.uptodate' -a true = \${varICONS} ] && echo true)">break:</action>
        ${DEBUG:+<action>if true echo >&2 in true rebuilding database...</action>}
        <action>if true gawk -v ALL_ICONS=\${varICONS} -f '${AWKB}' ${LOCS} > '${DATF}'</action>
        ${DEBUG:+<action>if true echo >&2 in true clear:varLIST</action>}
        <action>if true clear:varLIST</action>
        ${DEBUG:+<action>if true echo >&2 in true refresh:varLIST</action>}
        <action>if true refresh:varLIST</action>
        ${DEBUG:+<action>if false echo >&2 in false rm -f \{~/.icons\|/usr/share/pixmaps\}/findnrun-\*</action>}
        <action>if false rm -f '${ICONSTEM:-/tmp/dummy}'*</action>
        ${DEBUG:+<action>if false echo >&2 in false rebuilding database...</action>}
        <action>if false gawk -v ALL_ICONS=\${varICONS} -f '${AWKB}' ${LOCS} > '${DATF}'</action>
        ${DEBUG:+<action>if false echo >&2 in false clear:varLIST</action>}
        <action>if false clear:varLIST</action>
        ${DEBUG:+<action>if false echo >&2 in false refresh:varLIST</action>}
        <action>if false refresh:varLIST</action>
      </checkbox>
      ${REMARK# ]]]}
      ${REMARK# [[[. varFOCUSSEARCH checkbox}
      <checkbox use-underline="true" tooltip-text="$(gettext "Move the keyboard focus to the search input field after starting an item instead of keeping the keyboard focus on the started list item. This option also affects the command input field.")">
        <label>$(gettext "_Focus search")</label>
        <default>${varFOCUSSEARCH}</default>
        <variable>varFOCUSSEARCH</variable>
        ${DEBUG:+<action>echo>&2 ,,, varFOCUSSEARCH ,,,</action>}
        <action>awk -v s=varFOCUSSEARCH=\${varFOCUSSEARCH} '/^varFOCUSSEARCH=/{\$0=s;f=1}{a[++n]=\$0}END{if(!f)a[++n]=s;++n;for(i=1;i!=n;i++)print a[i]>ARGV[1]}' '${CONFIG}'</action>
      </checkbox>
      ${REMARK# ]]]}
      <text space-fill="true" space-expand="true"><label>""</label></text>
      ${REMARK# [[[. 'help' button}
      <button tooltip-text="$(gettext "About and help")" stock-icon-size="1">
        <input file stock="gtk-about"></input>
        <action>launch:GUI_ABOUT</action>
      </button>
      ${REMARK# ]]]}
      ${REMARK# [[[. 'exit' button}
      <button tooltip-text="$(gettext "Exit")" stock-icon-size="1">
        <input file stock="gtk-quit"></input>
        <action>exit:EXIT</action>
      </button>
      ${REMARK# ]]]}
    </hbox>
    ${REMARK# ]]]}
    ${REMARK# [[[. varSBAR statusbar}
    ${REMARK# Do not vbox the status bar here; keep the vbox under the control}
    ${REMARK# of generate_status_bar to be able to hide the status bar without}
    ${REMARK# leaving a tiny empty strip at the bottom of the main window.}
    $(generate_status_bar)
    ${REMARK# ]]]}
  </vbox>
  ${REMARK# Do not vbox/hbox hidden widgets because boxes add some unnecessary (tiny) padding.}
  ${REMARK# [[[. Cached source declaration variables (hidden).}
  <entry visible="false" sensitive="false">
    <variable>TAP</variable>
    ${REMARK# Cache TAP until next refresh:TAP.}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${TAP}"</input>
    ${DEBUG:+<action>echo>&2 ,,, TAP ,,,</action>}
  </entry>
  <entry visible="false" sensitive="false">
    <variable>DRAIN</variable>
    <default>debug2</default>
    ${REMARK# Cache DRAIN until next refresh:DRAIN.}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${DRAIN}"</input>
    ${DEBUG:+<action>echo>&2 ,,, DRAIN ,,,</action>}
  </entry>
  <entry visible="false" sensitive="false">
    <variable>ICON</variable>
    <default>${ICON:-null}</default>
    ${REMARK# Cache ICON until next refresh:ICON.}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${ICON}"</input>
    ${DEBUG:+<action>echo>&2 ,,, ICON ,,,</action>}
  </entry>
  <entry visible="false" sensitive="false">
    <variable>TITLE</variable>
    <default>debug3</default>
    ${REMARK# Cache TITLE until next refresh:TITLE.}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${TITLE}"</input>
    ${DEBUG:+<action>echo>&2 ,,, TITLE ,,,</action>}
  </entry>
  <entry visible="false" sensitive="false">
    <variable>SOURCE</variable>
    <default>${SOURCE}</default>
    ${REMARK# Cache SOURCE until next refresh:SOURCE}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${SOURCE}"</input>
    ${DEBUG:+<action>echo>&2 ,,, SOURCE ,,,</action>}
  </entry>
  <entry visible="false" sensitive="false">
    <variable>ID</variable>
    <default>${ID}</default>
    ${REMARK# Cache ID until next refresh:ID.}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${ID}"</input>
    ${DEBUG:+<action>echo>&2 ,,, ID ,,,</action>}
  </entry>
  <entry visible="false" sensitive="false">
    <variable>NSOURCES</variable>
    <default>${NSOURCES}</default>
    ${REMARK# Cache NSOURCES until next refresh:NSOURCES.}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${NSOURCES}"</input>
    ${DEBUG:+<action>echo>&2 ,,, NSOURCES ,,,</action>}
  </entry>
  <entry visible="false" sensitive="false">
    <variable>INITSEARCH</variable>
    ${REMARK# Cache INITSEARCH until next refresh:INITSEARCH}
    <input>${DEBUG:+set +x; }. "${SRCSTEM}\${varF3:-0}-"*.sh && echo -n "\${INITSEARCH}"</input>
    ${DEBUG:+<action>echo>&2 ,,, INITSEARCH ,,,</action>}
  </entry>
  ${REMARK# ]]]}
  ${REMARK# [[[. Hotkey targets (hidden).}
  ${REMARK#  [[[. refresh:varF2 to cycle focus between the search field and the command entry field.}
  ${REMARK# Key F2 demonstrates how.}
  <checkbox visible="false">
    <default>false</default>
    <label>F2</label>
    <variable>varF2</variable>
    <input file>${F2SF}</input>
    ${DEBUG:+<action>echo>&2 ,,, varF2 ,,,</action>}
    <action>if true grabfocus:varCMD</action>
    <action>if false grabfocus:varSEARCH</action>
  </checkbox>
  ${REMARK#  ]]]}
  ${REMARK#  [[[. refresh:varF3 to switch the list view to another source.}
  ${REMARK# Key F3 demonstrates how.}
  <entry visible="false" sensitive="false">
    <variable>varF3</variable>
    <default>0</default>
    <input file>${F3SF}</input>
    ${DEBUG:+<action>echo>&2 ,,, varF3 ,,,</action>}
    ${REMARK# [[[. Optimization: Cache current source values.}
    <action>refresh:TAP</action>
    <action>refresh:DRAIN</action>
    <action>refresh:ICON</action>
    <action>refresh:TITLE</action>
    <action>refresh:SOURCE</action>
    <action>refresh:ID</action>
    ${REMARK# ]]]}
    ${DEBUG:+<action>echo>&2 ,,, refresh varSBAR [[</action>}
    <action>refresh:varSBAR</action>
    ${DEBUG:+<action>echo>&2 ]] ,,,</action>}
    <action>clear:varSEARCH</action>
    <action>enable:varSEARCH0</action>
    <action>refresh:varLIST</action>
  </entry>
  ${REMARK#  ]]]}
  ${REMARK# ]]]}
  ${REMARK# [[[. Hotkey actions (hidden).}
  <action signal="key-press-event" condition="command_is_true([ \$KEY_SYM = Escape ] && echo true )">exit:EXIT</action>
  <action signal="key-press-event" condition="command_is_true([ \$KEY_SYM = F1 ] && echo true )">${helpviewer:-:} &</action>
  ${REMARK#  [[[. Key F2 cycles focus between the search and the command entry field.}
  <action signal="key-press-event" condition="command_is_true([ \$KEY_SYM = \"${HOTKEY_F2}\" ] && echo true )">case \${varF2:-false} in true) echo false;; false) echo true;; esac >"${F2SF}"</action>
  <action signal="key-press-event" condition="command_is_true([ \$KEY_SYM = \"${HOTKEY_F2}\" ] && echo true )">refresh:varF2</action>
  ${REMARK#  ]]]}
  ${REMARK#  [[[. Key F3 cycles the list view among builtin and plugin sources.}
  <action signal="key-press-event" condition="command_is_true([ \$KEY_SYM = \"${HOTKEY_F3}\" ] && echo true )">set -- ${SOURCES}; echo -n \$(((\${varF3} + 1) % \$#))>"${F3SF}"</action>
  <action signal="key-press-event" condition="command_is_true([ \$KEY_SYM = \"${HOTKEY_F3}\" ] && echo true )">refresh:varF3</action>
  ${REMARK#  ]]]}
  $(generate_source_hotkeys)
  ${REMARK# ]]]}
  <action signal="delete-event">exit:abort</action>
</window>
EOF

# i18n This application's own .desktop file. [[[1
# i18n Optionally translate the Name[xx] field to be added to file findnrun.desktop
# i18n Do NOT include ending ' ' in your translation, assume that it isn't there.
Name=$(gettext "Find'N'Run ")
# i18n Optionally translate the Comment[xx] field to be added to file findnrun.desktop
Comment=$(gettext "Find and run applications very quickly")

