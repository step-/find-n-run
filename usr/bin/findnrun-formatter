#!/usr/bin/gawk -f
# vim: foldmarker=[[[,]]]:

# =============================================================================
# findnrun-formatter script
# Version=1.0
# Author: step
# license: GNU GPL applies
# source: https://github.com/step-/find-n-run
# =============================================================================

# Usage: source | findnrun-formatter [-S source-id] [-I icon-filename] [-T title] [-O options] [-v verbosity-level]

# Source plugin formatter script [[[1
BEGIN {
  Version = "1.0"
  Program = "findnrun-formatter"
  Opterr = 1    # default is to diagnose
  Optind = 1    # skip ARGV[0]

  while ((_go_c = getopt(ARGC, ARGV, "S:I:T:O:hv:")) != -1)
    opt[_go_c] = Optarg
#  printf("non-option arguments:\n")
#  for (; Optind < ARGC; Optind++)
#    printf("\tARGV[%d] = <%s>\n", Optind, ARGV[Optind])

  # Clear out all option args so they aren't interpreted as filenames.
  for(i = 0; i <= Optind; i++) delete ARGV[i]

  if("h" in opt) {
    printf("%s %s\nusage: <command> | %s -- [ <options> ]\n<options>:\n", \
           Program, Version, Program)
    print "  -h\t\t\tprint this message and exit\n" \
          "  -I icon-filename\n" \
          "  -O options\t\ta string of letters: 's'\n" \
          "  -S source-id\n" \
          "  -T source-title\n" \
          "  -v level\t\tprint progress info to stderr, level integer > 0"
    exit
  }
  if(opt["v"] > 2) {
    printf("\nfindnrun-formatter: source='%s' icon='%s' title='%s' hints='%s'\n",
           opt["S"], opt["I"], opt["T"], opt["O"]) >"/dev/stderr"
  }
  # Optimize well-known sources and single-field case.
  if(index(opt["O"], "s")) {
    RS="^~cannot~match~me~" # enable slurp read mode.
  }
  else
  {
    IFS="|"
  }
  SEP="\x08"
}
# Optimize well-known sources and single-field case.
index(opt["O"], "s") {
  for(i=1; i <= NF; i++)
    print opt["I"] "||" $(i) "|path" SEP $(i) SEP $(i) SEP
  exit
}
# Multi-field case.
{
  print "Multiple-field formatting to be implemented." > "/dev/stderr" # TODO
  print "||Multiple-field formatting to be implemented." # TODO
  exit
}

# getopt.awk --- Do C library getopt(3) function in awk [[[1
#
# Arnold Robbins, arnold@skeeve.com, Public Domain
#
# Initial version: March, 1991
# Revised: May, 1993

# External variables:
#    Optind -- index in ARGV of first nonoption argument
#    Optarg -- string value of argument to current option
#    Opterr -- if nonzero, print our own diagnostic
#    Optopt -- current option letter

# Returns:
#    -1     at end of options
#    "?"    for unrecognized option
#    <c>    a character representing the current option

# Private Data:
#    _opti  -- index in multiflag option, e.g., -abc
function getopt(argc, argv, options,    thisopt, i)
{
    if (length(options) == 0)    # no options given
        return -1

    if (argv[Optind] == "--") {  # all done
        Optind++
        _opti = 0
        return -1
    } else if (argv[Optind] !~ /^-[^:[:space:]]/) {
        _opti = 0
        return -1
    }
    if (_opti == 0)
        _opti = 2
    thisopt = substr(argv[Optind], _opti, 1)
    Optopt = thisopt
    i = index(options, thisopt)
    if (i == 0) {
        if (Opterr)
            printf("%c -- invalid option\n", thisopt) > "/dev/stderr"
        if (_opti >= length(argv[Optind])) {
            Optind++
            _opti = 0
        } else
            _opti++
        return "?"
    }
    if (substr(options, i + 1, 1) == ":") {
        # get option argument
        if (length(substr(argv[Optind], _opti + 1)) > 0)
            Optarg = substr(argv[Optind], _opti + 1)
        else
            Optarg = argv[++Optind]
        _opti = 0
    } else
        Optarg = ""
    if (_opti == 0 || _opti >= length(argv[Optind])) {
        Optind++
        _opti = 0
    } else
        _opti++
    return thisopt
}

